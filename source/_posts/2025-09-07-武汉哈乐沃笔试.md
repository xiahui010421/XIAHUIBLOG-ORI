---
title: 武汉哈乐沃笔试
date: 2025-09-07T07:20:00.000Z
tags: [秋招]
categories: 笔试
---

## 一、JavaScript 数据类型与转换
### 1. 基本数据类型
- **核心考点**：区分 JS 原生基本数据类型，排除干扰项  
- 正确基本类型：`String`（字符串）、`Number`（数字，含整数/浮点数）、`Boolean`（布尔）、`Undefined`（未定义）、`Null`（空值）、`Symbol`（符号）、`BigInt`（大整数）  
- 常见干扰项：`Float`（JS 无单独浮点数类型，浮点数包含在 `Number` 中）  

### 2. 类型转换
- **核心考点**：`Number()` 函数转换规则、字符串与数字的运算行为  
- `Number(undefined)`：返回 `NaN`（非数字）  
- 字符串 + 数字：触发字符串拼接（如 `"1555" + 3` 结果为 `"15553"`）  


## 二、JavaScript 变量声明（let vs var）
| 对比维度       | var                          | let                          |
|----------------|------------------------------|------------------------------|
| 作用域         | 仅函数作用域，无块级作用域   | 支持块级作用域（if/for/{} 内有效） |
| 变量提升       | 完整提升，未赋值时为 `undefined` | 有暂时性死区（TDZ），提升后不可访问 |
| 重复声明       | 允许同一作用域重复声明       | 禁止同一作用域重复声明       |  


## 三、JavaScript 函数与 this 指向
### 1. 普通函数 vs 箭头函数的 this 差异
- **普通函数**：this 指向「调用它的对象」（如 `object.greet()` 中，this 指向 `object`）；直接调用（如 `greet2()`）时，this 指向全局对象（window）  
- **箭头函数**：无自身 this，this 继承「定义时所在作用域的 this」（如对象内的箭头函数，this 指向全局而非对象）  

### 2. JSON 相关方法
- **核心考点**：JSON 解析与序列化的方法区分  
- `JSON.parse(str)`：将 JSON 字符串解析为 JS 对象（正确）  
- `JSON.stringify(obj)`：将 JS 对象转换为 JSON 字符串（与解析相反）  
- 干扰项：`Object.parseJSON()`、`String.parseJSON()`（JS 中无这两个方法）  


## 四、JavaScript 数组操作
### 1. 数组去重
- **常用方法**：  
  1. `Set` 去重：`[...new Set(arr)]`（简洁高效，利用 Set 元素唯一性）  
  2. `filter + indexOf`：筛选「第一次出现的元素」（`arr.filter((item, idx) => arr.indexOf(item) === idx)`）  
  3. 循环 + 新数组：遍历判断元素是否在新数组中，不在则添加  

### 2. 数组排序
- **核心考点**：`Array.sort()` 方法的默认行为与自定义比较函数  
- 默认排序：按字符串 Unicode 编码升序（数字简单升序可直接用，复杂需自定义）  
- 自定义排序：  
  - 升序：`arr.sort((a, b) => a - b)`  
  - 降序：`arr.sort((a, b) => b - a)`  


## 五、编程基础与算法
### 1. 数据结构应用（缓存技术）
- **核心考点**：不同数据结构的特性与缓存需求匹配度  
- 适合缓存的结构：栈（后进先出，支持特定顺序缓存）、队列（先进先出，FIFO 淘汰策略）、哈希表（键值对快速存取）  
- 不适合缓存的结构：图（用于表示复杂关系，不满足缓存高效存取需求）  

### 2. 二分查找算法
- **适用场景**：有序数组的目标值查找  
- **核心逻辑**：  
  1. 初始化左右指针（left=0，right=数组长度-1）  
  2. 循环计算中间索引 `mid = Math.floor((left + right) / 2)`  
  3. 比较 `nums[mid]` 与目标值：  
     - 相等：返回 mid（目标索引）  
     - `nums[mid] < 目标值`：left = mid + 1（目标在右半区）  
     - `nums[mid] > 目标值`：right = mid - 1（目标在左半区）  
  4. 循环结束未找到：返回 -1
